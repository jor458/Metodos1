import numpy
m=int(input('Valor de m:'))
n=int(input('Valor de n:'))
matrix = numpy.zeros((m,n))
x=numpy.zeros((m))


vector=numpy.zeros((n))
comp=numpy.zeros ((m))
error=[]



print ('Método de Gauss-Seidel')
print ('Introduce la matriz de coeficientes y el vector solución')
for r in range(0,m):
    for c in range(0,n):
        matrix[(r),(c)]=float(input("Elemento a["+str(r+1)+str(c+1)+"] "))
    vector[(r)]=float(input('b['+str(r+1)+']: '))
print ("Método de Gauss-Seidel")
tol=float(input("cual es el tamaño que deseas? "))
itera=int(input( "cual es el numero maximo de iteraciones? ")) 


k=0
while k < itera:
    suma=0
    k=k+1
    for r in range(0,m):
        suma=0
        for c in range(0,n):
            if (c != r):
                suma=suma+matrix[r,c]*x[c]               
        x[r]=(vector[r]-suma)/matrix[r,r]
        print("x["+str(r)+"]: "+str(x[r]))
        del error[:] 


    #Comprobación

    for r in range(0,m):
        suma=0
        for c in range(0,n):
                suma=suma+matrix[r,c]*x[c] 
                comp[r]=suma 
                dif=abs(comp[r]-vector[r])
                error.append(dif)  
                print("Error en x[",r,"]= ",error[r])
                print("Iteraciones:  ",k)
                if all(  i<=tol for i in error) == True:
                  break
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  2 codigo gaus seidel 
                  
                   matrices, métodos iterativos
# Referencia: Chapra 11.2, p.310, pdf.334
#      Rodriguez 5.2 p.162
# ingresar iteramax si requiere más iteraciones

import numpy as np

def gauss_seidel(A,B,tolera,X,iteramax=100):
    tamano = np.shape(A)
    n = tamano[0]
    m = tamano[1]
    diferencia = np.ones(n, dtype=float)
    errado = np.max(diferencia)
    
    itera = 0
    while not(errado<=tolera or itera>iteramax):
        for i in range(0,n,1):
            nuevo = B[i]
            for j in range(0,m,1):
                if (i!=j): # excepto diagonal de A
                    nuevo = nuevo-A[i,j]*X[j]
            nuevo = nuevo/A[i,i]
            diferencia[i] = np.abs(nuevo-X[i])
            X[i] = nuevo
        errado = np.max(diferencia)
        itera = itera + 1
    # Vector en columna
    X = np.transpose([X])
    # No converge
    if (itera>iteramax):
        X=0
    return(X)

# Programa de prueba #######
# INGRESO
A = np.array([[3,-0.1,-0.2],
              [0.1,7,-0.3],
              [0.3,-0.2,10]])

B = np.array([7.85,-19.3,71.4])

tolera = 0.00001

# PROCEDIMIENTO
n = len(B)
X = np.zeros(n, dtype=float)
respuesta = gauss_seidel(A,B,tolera,X)
verifica = np.dot(A,respuesta)

# SALIDA
print('respuesta de A.X=B : ')
print(respuesta)
print('verificar A.X: ')
print(verifica)

que da como resultado:

respuesta de A.X=B : 
[[ 3. ]
 [-2.5]
 [ 7. ]]
verificar A.X: 
[[  7.84999999]
 [-19.3       ]
 [ 71.4       ]]
                  
                  
                  
                  
